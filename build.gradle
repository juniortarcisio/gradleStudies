/*
	A bunch of tests that I'm doing and I would like to save in case
	I want to take a look later or to make further tests.
	
	Initially I'm using the free classes on Udacity as a base for my studies
	So many of the tests here may looks similar to the ones from there.
	
	useful links:
	https://classroom.udacity.com/courses/ud867/
	http://groovy-lang.org/documentation.html
	https://learnxinyminutes.com/docs/groovy/
	https://github.com/apache/groovy
*/

task groovy << {}

println "Hello Groovy"

class JavaGreeter {
	public static void sayHello() {
		System.out.println("Hello Java!");
	}
}

JavaGreeter greeter = new JavaGreeter()
greeter.sayHello()

def foo = 6.5

println "foo has value : $foo"

println "Calculation test: ${5 + 6}"

println "type of foo: ${foo.class}"

foo = "a string"

println "foo has value : $foo"

println "type of foo: ${foo.class}"

def powIt(n) {
	n * n
}

foo = 9
println "powIt $foo result: ${powIt(foo)}"

def funcOneArg(x) {
	println "Called the function funcOneArg with arg $x"
	x
}

def funcTwoArgs(x,y) {
	println "Called the function funcTwoArgs with the args $x and $y"
	x + y
}

funcOneArg 1
funcTwoArgs 2, 3

funcTwoArgs funcOneArg(1), 2

task helloWorld {
    doLast{
        println "Hello, World!"        
    }
}

task functionsTesting {
	doLast {
		def xoo = "Whatever you want"
		def myClosureFunction = {
			println "Closure functions also capture variables from it's enclosing environment"
			println "Capturing the value of xoo: $xoo"
		}
		
		myClosureFunction()
		
		println "It also can be passed to variables (like a delegate)"
		def xar = myClosureFunction
		def xuu = xar
		xuu()
				
		def powItClosure = { x ->  x * x }
		
		def applyTwice = { func, arg -> func(func(arg)) }
		
				
		def testApplyTwiceResult = applyTwice(powItClosure, 3)
		println "Executing powIt twice gives you the result $testApplyTwiceResult"
	}
}

task listsTesting {
	doLast {
		def myList = [1,2,4]
		def sum = 0
		
		def printItem = { item -> println "item: $item" }
		def sumItem = { item -> sum = sum + item }
		
		myList.each(printItem)
		myList.each(sumItem)
		
		println "the sum is: $sum"
		
		myList.each{println "Compactly printing: $it"}
	}
}

/* Classes cannot be declared inside a task */
class MyClass {
	String name = "Mr. Robot"
	def printWelcome() { println "Welcome $name" }
}

task classesTesting {
	doLast {
		
		def myObject = new MyClass()
		
		myObject.printWelcome()
		myObject.name = "Tarcisio"
		myObject.printWelcome()
		
		def functionDelegatingClosure = {
			name = "Jowls Beans"
			printWelcome()
		}
		
		functionDelegatingClosure.delegate = myObject
		functionDelegatingClosure()
	}
}


task putOnSocks {
	doLast {
		println "Putting on Socks"
	}
}

task putOnShoes {
	dependsOn "putOnSocks"
	doLast {
		println "Putting on Shoes"
	}
}

/* 
grande -q putOnShoes 
	   -q quite mode, doesn't output diagnostic messages 
	   
automatically runs the dependent task
	
...	
Putting on Socks
Putting on Shoes
...

*/

task eatBreakFast {
	finalizedBy "brushYourTeeth"
	doLast {
		println "Nhac nhac nhac! Breakfast!"
	}
}

task brushYourTeeth {
	doLast {
		println "Brushie Brushie Brushie..."
	}
}



task takeShower {	
	doLast {
		println "Taking a shower"
	}
}

task putOnFragance {
	shouldRunAfter "takeShower"
	doLast {
		println "Putting a smelly fragance"
	}
}


/* 
grande -q putOnFragance takeShower
	   
automatically reorder to take the shower first
	
...	
Taking a shower
Putting a smelly fragance
...

*/

task getReady {
	dependsOn = ["putOnFragance","eatBreakFast","takeShower","putOnShoes"]
}

putOnSocks.mustRunAfter takeShower

/* 
grande -q getReady
	   
runs on the following order
...	
bfast, brush, shower, fragance, socks, shoes...
...

*/

task getEquipped {
	dependsOn tasks.matching{ task -> task.name.startsWith("putOn") }
	doLast {
		println "All geared up!"
	}
}
